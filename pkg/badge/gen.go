// +build ignore

package main

import (
	"bytes"
	"fmt"
	"go/format"
	"io/ioutil"
	"log"
	"math"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"text/template"

	"github.com/golang/freetype/truetype"
	"golang.org/x/image/math/fixed"
)

// Support up to Latin-1 Supplement (Unicode block)
const maxCharCode = 0xFF

type datum struct {
	Name  string
	Value string
}

func main() {
	err := run()
	if err != nil {
		log.Fatalln(err)
	}
}

func run() error {
	var Verdana9CharWidths = make([]int, maxCharCode)
	var Verdana11CharWidths = make([]int, maxCharCode)
	for i := 0; i < maxCharCode; i++ {
		var err error
		Verdana9CharWidths[i], err = computeCharWidth("Verdana", 9, rune(i))
		if err != nil {
			return err
		}
		Verdana11CharWidths[i], err = computeCharWidth("Verdana", 11, rune(i))
		if err != nil {
			return err
		}
	}

	badgeTemplates := make([]datum, 0)
	if err := filepath.Walk("assets/templates",
		func(path string, info os.FileInfo, walkErr error) error {
			if !info.IsDir() && strings.HasSuffix(info.Name(), ".tmpl") {
				tmpl, readFileErr := ioutil.ReadFile(path)
				if readFileErr != nil {
					return readFileErr
				}

				badgeTemplates = append(badgeTemplates, datum{
					Name: strings.TrimSuffix(info.Name(), ".tmpl"),
					Value: string(tmpl),
				})
			}

			return walkErr
		}); err != nil {
		return err
	}

	icons := make([]datum, 0)
	if err := filepath.Walk("assets/icons",
		func(path string, info os.FileInfo, walkErr error) error {
			if !info.IsDir() && strings.HasSuffix(info.Name(), ".svg") {
				svg, readFileErr := ioutil.ReadFile(path)
				if readFileErr != nil {
					return readFileErr
				}

				icons = append(icons, datum{
					Name: strings.TrimSuffix(strings.TrimPrefix(path, "assets/icons/"), ".svg"),
					Value: string(svg),
				})
			}

			return walkErr
		}); err != nil {
		return err
	}

	data := map[string]interface{}{
		"Icons":               icons,
		"Templates":           badgeTemplates,
		"Verdana9CharWidths":  Verdana9CharWidths,
		"Verdana11CharWidths": Verdana11CharWidths,
	}
	for filename, t := range templates {
		var buf bytes.Buffer
		err := t.Execute(&buf, data)
		if err != nil {
			return err
		}

		// Run `go fmt` on template output
		out, err := format.Source(buf.Bytes())
		if err != nil {
			log.Println(err)
			out = []byte("// gofmt error: " + err.Error() + "\n\n" + buf.String())
		}

		fmt.Printf("writing %s...\n", filename)
		err = ioutil.WriteFile(filename, out, 0644)
		if err != nil {
			return err
		}
	}

	return nil
}

func computeCharWidth(fontFamily string, fontSize int, character rune) (int, error) {
	filePath := fmt.Sprintf("assets/fonts/%s.ttf", fontFamily)
	ttf, err := ioutil.ReadFile(filePath)
	if err != nil {
		return 0, fmt.Errorf("failed to open font file: %v", err)
	}

	font, err := truetype.Parse(ttf)
	if err != nil {
		return 0, fmt.Errorf("failed to parse font file: %v", err)
	}

	fUnitsPerEm := fixed.Int26_6(font.FUnitsPerEm())
	ttIndex := font.Index(character)
	horizontalMetric := font.HMetric(fUnitsPerEm, ttIndex)
	charWidth := horizontalMetric.AdvanceWidth

	return int(math.Round(float64(charWidth) / float64(fUnitsPerEm) * float64(fontSize))), nil
}

// Filename -> Template.
var templates = map[string]*template.Template{
	"char_width.go": t(`// Code generated by gen.go; DO NOT EDIT.
package badge

var (
	// verdana9CharWidths is an array of character widths from the Verdana font-family with font-size of 9px & indexed by their respective UTF-16 code unit
	verdana9CharWidths = {{.Verdana9CharWidths | stringifyIntSlice}}
	// verdana11CharWidths is an array of character widths from the Verdana font-family with font-size of 11px & indexed by their respective UTF-16 code unit
	verdana11CharWidths = {{.Verdana11CharWidths | stringifyIntSlice}}
)
`),
	"icons.go": t(`// Code generated by gen.go; DO NOT EDIT.
package badge

// iconName -> svg
var fontAwesomeIcons = map[string]string{
	{{- range .Icons}}
	"{{.Name}}": ` + "`" + `{{.Value | minifyString}}` + "`" + `,
	{{- end}}
}
`),
	"templates.go": t(`// Code generated by gen.go; DO NOT EDIT.
package badge

import "text/template"

// styleName -> template
var badgeTemplates = map[Style]*template.Template{
	{{- range .Templates}}
	"{{.Name}}": template.Must(template.New("").Parse(` + "`" + `{{.Value | minifyString}}` + "`" + `)),
	{{- end}}
}
`),
}

func t(text string) *template.Template {
	return template.Must(template.New("").Funcs(template.FuncMap{
		"minifyString": func(s string) string {
			return regexp.MustCompile(`[\n\r\t]`).ReplaceAllString(s, "")
		},
		"stringifyIntSlice": func(s []int) string {
			return fmt.Sprintf("[...]int {%s}", strings.Trim(strings.Join(strings.Fields(fmt.Sprint(s)), ","), "[]"))
		},
	}).Parse(text))
}
